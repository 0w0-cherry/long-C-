.const的修饰
const Data* p;//修饰的是指针的内容
Data* const p;//修饰的是指针

2.this指针的特点
(1)形参和实参的位置，不能显示写
(2)函数内部可以使用
(3)类的成员函数的参数是 n+1个(n表示的是显示的参数)
(4)是一个形参，因此存储在栈上(有些编译器如vs可能会用寄存器传递)

3.常量字面量
(1)取地址运算符不能作用于常量字面量上。因为从翻译后的二进制的角度来讲，这些直接书写在代码里的常量字面量是由硬件直接产生的，是不具有地址属性的
(2)经 const 关键字修饰的变量经初始化赋值后不可再修改。但是从二进制的角度来讲，它与变量无任何区别，同样是存储在内存中，因此可以取地址。

4.构造函数
1.定义：是特殊的成员函数，负责初始化对象。
2.语法定义：
(1)函数名与类名相同
(2)无返回值
(3)对象实例化时编译器自动调用对应的构造函数。一旦用户显示定义，编译器不再生成，若不写，编译器会自动生成默认成员的参数
(4)构造函数可以重载，且重载允许半缺省，但缺省构造函数(全缺省/无参数)只能有一个(避免调用歧义)。重载后仍是特殊的成员函数
(5)对内置类型不做处理，自定义类型会调用它的默认构造函数(但在C++11委员会对该语法打补丁：可在声明位置给缺省值。但一般仍然额外手动初始化)
(6)不需要传参就能构造函数，都可以称作默认构造函数 或 缺省构造函数(无参、全缺省)，且默认构造函数只能有一个(无参、全缺省)
3.格式：
Data d1;
Data d2(2024);//重载
Data d1();//错误写法

5.析构函数
1.析构函数名在类名前面加字符"~"
2.参数无返回类型
3.一个类只能有析构函数，系统会自动生成默认的析构(析构函数不能重载)
4.对象生命周期结束时，C++编译系统自动调用析构函数。且后定义的先析构，后进先出(相当于destroy，避免内存泄漏)
5.内置类型不做处理，自定义类型去调用它的析构
