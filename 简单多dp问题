
https://leetcode.cn/problems/delete-and-earn/
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        int arr[10001]={0};
        for(auto x:nums)
        {
            arr[x]+=x;
        }

        vector<int> f(10001);
        auto g=f;
        f[0]=arr[0];
        g[0]=0;
        for(int i=1;i<10001;i++)
        {
            f[i]=g[i-1]+arr[i];
            g[i]=max(f[i-1],g[i-1]);
        }
        return max(f[10000],g[10000]);
    }
};

https://leetcode.cn/problems/delete-and-earn/
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        int arr[10001]={0};
        for(auto x:nums)
        {
            arr[x]+=x;
        }

        vector<int> f(10001);
        auto g=f;
        f[0]=arr[0];
        g[0]=0;
        for(int i=1;i<10001;i++)
        {
            f[i]=g[i-1]+arr[i];
            g[i]=max(f[i-1],g[i-1]);
        }
        return max(f[10000],g[10000]);
    }
};


https://leetcode.cn/problems/PzWKhm/
class Solution {
public:
    int rob(vector<int>& nums) {
        int n=nums.size();

        return max(nums[0]+rob1(nums,2,n-2),rob1(nums,1,n-1));
    }

    int rob1(vector<int>& nums,int left,int right)
    {
        if(left>right)//n-1必须大于1，无需额外判断数组为空
        return 0;

        int n=nums.size();
        vector<int> f(n);
        auto g=f;
        f[left]=nums[left];
        g[left]=0;
        for(int i=left;i<=right;i++)
        {
            f[i]=g[i-1]+nums[i];
            g[i]=max(f[i-1],g[i-1]);
        }
        return max(f[right],g[right]);
    }
};


https://leetcode.cn/problems/JEj789/
class Solution {
public:
    int minCost(vector<vector<int>>& costs) {
        int n=costs.size();
        if(n==0)
        return 0;
        vector<vector<int>> dp(n+1,vector<int> (3));
        //每个房前的虚拟节点为0
        for(int i=1;i<=n;i++)
        {
            dp[i][0]=min(dp[i-1][1],dp[i-1][2])+costs[i-1][0];//注意下标的位移
            dp[i][1]=min(dp[i-1][0],dp[i-1][2])+costs[i-1][1];
            dp[i][2]=min(dp[i-1][0],dp[i-1][1])+costs[i-1][2];
        }
        return min(min(dp[n][0],dp[n][1]),dp[n][2]);
    }
};
