#pragma once
//.h文件在预处理阶段展开(编译器在实际编译时没有.h)，因此此处可不包头文件，但queue.h必须被包含在在包含了所需头文件的文件中
namespace bit
{
	template<class T, class Container = deque<T>>
	class queue
	{
	public:
		void push(const T& x)
		{
			_con.push_back(x);
		}
		void pop()
		{
			_con.pop_();
		}
		size_t size()
		{
			return _con.size();
		}
		bool empty()
		{
			return _con.empty();
		}
		const T& front()
		{
			return _con.front();
		}
		const T& back()
		{
			return _con.back();
		}
	private:
		Container _con;
	};

	//仿函数
	template<class T>
	class less
	{
	public:
		bool operator()(const T& x, const T& y)
		{
			return x < y;
		}
	};
	template<class T>
	class greater
	{
	public:
		bool operator()(const T& x, const T& y)
		{
			return x > y;
		}
	};
	//优先级队列
	template<class T,class Container=vector<T>,class Compare=less<T>>
	class priority_queue
	{
	public:
		void adjust_up(size_t child)
		{
			Compare com;
			size_t parent = (child - 1) / 2;
			while (child>0)
			{
				//if(_con[parent]<_con[child])
				if (com(  _con[parent], _con[child])  )
				{
					swap(_con[child], _con[parent]);
					child = parent;
					parent = (child - 1) / 2;
				}
				else
					break;
			}
		}

		void push(const T& x)
		{
			_con.push_back(x);
			//adjust_up(_con.size() - 1);
			adjust_down(_con.size() - 1);
		}

		//小堆
		void adjust_down(size_t parent)
		{
			Compare com;
			size_t child = parent * 2 + 1;//默认左孩子
			while (child<_con.size())
			{
				//if (child + 1 < _con.size() && _con[child + 1] > _con[child])
				//if (child + 1 < _con.size() && _con[child ] < _con[child+1])
				if (child + 1 < _con.size() &&  com( _con[child], _con[child + 1])  )
				{
					child = child + 1;
				}
				//if (_con[parent] < _con[child])
				if(com(_con[parent],_con[child]))
				{
					swap(_con[parent], _con[child]);
					parent = child;
					child = parent * 2 + 1;
				}
				else
				{
					break;
				}
			}
		}
		void pop()
		{
			swap(_con[0], _con[_con.size() - 1]);
			_con.pop_back();
			adjust_down(_con.size() - 1);
		}
		bool empty()
		{
			return _con.empty();
		}
		size_t size()
		{
			return _con.size();
		}
		const T& top()
		{
			return _con[0];
		}
	private:
		Container _con;
	};
}











#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;
#include"stack.h"
#include"queue.h"
#include<stack>
#include<list>
void test_stack1()
{
	bit::stack<int, list<int> > st;
	bit::stack<int> st0;
	st.push(1);
	st.push(2);
	while (!st.empty())
	{
		cout << st.top()<<" ";
		st.pop();
	}
	cout << endl;
}

#include<queue>
void test_priority_queue()
{
	//默认大的优先级高，底层是大堆
	priority_queue <int, vector<int>,greater<int>> pq;
	pq.push(1);
	pq.push(1);
	pq.push(3);

	//while (!pq.empty())
	//{
	//	cout << pq.top() << " ";
	//	pq.pop();
	//}
	//cout << endl;


	//降序
	vector<int> v = { 3,1,7,4,6,3 };
	greater<int> gt;
	sort(v.begin(), v.end(),gt);//有名对象
	sort(v.begin(), v.end(), greater<int>());//匿名对象
	for (auto e : v)
	{
		cout << e<<" ";
	}
	cout << endl;


	//priority_queue <int, vector<int>, greater<int>> pq;//模版传类型
	//sort(v.begin(), v.end(), greater<int>());//传对象

}
int main()
{
	//test_stack1();
	test_priority_queue();
	return 0;
}


//仿函数,可以像函数一样使用
template<class T>
class Less
{
public:
	bool operator()(const T& x, const T& y)
	{
		return x < y;
	}
};
int main1()
{

	Less<int> lessfunc;
	cout << lessfunc(1, 2) << endl;//有名对象
	cout << lessfunc.operator()(1, 2) << endl;//有名对象
	cout << Less<int>()(1, 2) << endl;//匿名对象
	cout << Less<int>().operator()(1, 2) << endl;//匿名对象

	return 0;
}












#include<vector>
#include<stack>
#include<deque>
namespace bit
{
	//适配器模式
	//stack<int, vector<int>> st1;//数组栈
	//stack<int, list<int>> st2;//链表栈
	template<class T,class Container=vector<T>>
	class stack
	{
	public:
		void push(const T& x)
		{
			_con.push_back(x);
		}
		void pop()
		{
			_con.pop_back();
		}
		size_t size()
		{
			return _con.size();
		}
		bool empty()
		{
			return _con.empty();
		}
		const T& top()
		{
			return _con.back();
		}
	private:
		Container _con;
	};
}





