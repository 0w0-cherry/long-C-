#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;


//new,delete:操作符
int main1()
{
	//创建对象
	int* p0 = (int*)malloc(sizeof(int));
	int* p1 = new int;
	int* p2 = new int[10];//10个int对象
	delete p0;
	delete p1;
	delete[] p2;

	//2.初始化
	int* p3 = new int(10);//new一个对象，初始化值10
	int* p4 = new int[10] {1, 2, 3, 4, 5};//剩余数组元素初始化为0
	delete p3;
	delete[] p4;

	return 0;
}

struct ListNode
{
	ListNode* _next;
	ListNode* _prev;
	int _val;
	ListNode(int val)
		:_next(nullptr)
		, _prev(nullptr)
		, _val(val)
	{}
};
struct ListNode* CreateListNode(int val)
{
	struct ListNode* newnode = (struct ListNode*)malloc(sizeof(struct ListNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return NULL;
	}

	newnode->_next = NULL;
	newnode->_prev = NULL;
	newnode->_val = val;
	return newnode;
}
ListNode* CreatList(int n)
{
	ListNode head(-1);
	ListNode* tail = &head;
	int val;
	for (size_t i = 0; i < n; i++)
	{
		cin >> val;
		tail->_next = new ListNode(val);
		tail = tail->_next;
	}
	return head._next;
}
void func()
{
	int n = 1;
	while (1)
	{
		int* p = new int[1024 * 1024 * 100];
		//int* p = (int*)malloc(1024 * 1024*4);

		cout << n << "->" << p << endl;
		++n;
	}
}
int main2()
{
	// 3、自定义类型，开空间+构造函数
    // 4、new失败了以后抛异常，不需要手动检查
	ListNode* node1 = new ListNode(1);
	ListNode* node2 = new ListNode(2);
	ListNode* node3 = new ListNode(3);
	ListNode* list1 = CreatList(5);

	//开辟空间时会获取异常，跨函数跳转
	try
	{
		func();
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;
	}
	return 0;
}

int main3()
{
	int* p1 = (int*)operator new(10 * 4);//开辟空间
	int* p2 = new int(10 * 4);//只会初始化分配的内存中的第一个 int 值为 40，而后续的内存不会被初始化，它们的值将是未定义的，可能是随机值。
	int* p3 = new int;//单个变量
	int* p4 = new int[10];//数组形式
	return 0;
}
class A
{
public:
	A(int a = 0)
		: _a(a)
	{
		cout << "A():" << this << endl;
	}

	~A()
	{
		cout << "~A():" << this << endl;
	}
private:
	int _a;
};
class Stack
{
public:
	Stack()
	{
		_a = (int*)malloc(sizeof(int) * 4);
		_top = 0;
		_capacity = 4;
	}

	~Stack()
	{
		free(_a);
		_top = _capacity = 0;
	}
private:
	int* _a;
	int _top;
	int _capacity;
};
int main4()
{
	A* ptr1 = new A;  // operator new + 1次构造

	//operator new[]，不止对operator new进行封装
	// 
	//申请开辟40字节，实际44字节
	//在头部额外申请4字节，用于存储元素个数。避免delete，不清楚元素个数等情况
	//不返回头部地址，返回第一个元素的地址
	A* ptr2 = new A[10]; // operator new[] + 10次构造

	//对于内置类型，不需要析构等,因此编译器不额外开辟空间存储元素个数
	int* p1 = new int[10];//40字节

	//A* ptr2 = new A[10];//40字节
	//且默认生成析构函数，默认生成的析构不需要元素个数，所以被编译器优化

	delete ptr1; // 1次析构 + operator delete
	delete[] ptr2; // 10次析构 + operator delete[]

	Stack* pst = new Stack;
	delete pst;

	return 0;
}


//
int main5()
{
	//可运行
	int* p1 = new int[10];
	delete p1;

	//正常情况下，析构函数显示写则不可运行(但具体看编译器会不会在头部开空间)
	//原因：开辟44字节空间，但返回的并非头部地址。因此delete从地址的中间开始释放，报错
	//同时，这也是 operator new[] 和 operator new的区别
	A* p2 = new A[10];
	delete p2;//从中间释放

	return 0;
}

int main()
{
	//效果与new 和 delete 等价
	A* p2 = (A*)operator new(sizeof(A));
	//显示调用构造函数，对已有空间初始化
	//new(指针) type(10) 或 new(指针) type()
	new(p2)A();

	p2->~A();
	return 0;
}
