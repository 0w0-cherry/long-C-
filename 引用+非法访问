对于引用，指针也能实现，但使用引用更方便

一.引用的规则
1.引用必须初始化
错误写法: 
 int& b;  
 b = a;
2.引用定义后，不能改变指向
int& b = a;
int c = 2;
b = c;//不是改变指向，而是赋值
3.一个变量可以有多个引用(别名),且别名和原名效果等价(一般情况下)
int& c = a;
int& d = a;
4.常引用
(1)引用变量
int b = 10;
const int &a = b;
b = 11;//b是可以修改的，但是a不能修改
(2)引用常量
const int &c = 15;
//编译器会给常量15开辟一片内存，并将引用名作为这片内存的别名

二：引用目的:
1.做参数(a、输出型参数  b、对象比较大,减少拷贝，提高效率)
2.做返回值
(1)返回变量除了函数作用域，生命周期到了就销毁，不能用引用返回
(2)全局变量/静态变量/堆上变量等可以用引用返回
3.细节：可能会造成越界访问(但仍可能获得值)，详细参考"引用-越界访问"


结语：
指针和引用的功能类似，重叠
C++的引用，对指针使用比较复杂的场景进行替换，简化代码
不能完全替代的原因：引用定义后，不能改变指向(实例：链表增删节点等)

三.非法访问
#include<iostream>
using namespace std;
int a = 10;
int func(int r)
{
a = r * r;
return a;
}
int& func1(int r)
{
a = r * r;
return a;
}
int main()
{
//错误写法: int& c = func(5);
措施：
int c=func1(5);
int& c=func1(5);//给a的别名起别名
理解步骤：
1.在func中，a将自身传入，func中对a的改变，会影响全局变量a
2.func(int r)传值返回a时，会产生一个临时对象，临时对象会被销毁。
3.int&c的意思是给返回的临时对象起别名，因此c作为返回时产生的临时对象的别名
4.因为临时对象会被销毁，因此c成为悬空引用(非法访问)
措施：
int &c=func1(5);
1.函数的返回类型是int&，因此返回时不返回临时对象，而返回全局变量a的别名
2.返回别名因此不产生临时对象，且生命周期比函数调用更长
核心需求：
让这个变量仍然有效，后续可被使用
return 0;
}
