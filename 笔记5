1.全局变量放静态区
2.字符串常量在代码段
3.sizeof计算时，包括"\0",strlen计算时不包含
4.一般字符串常量字符存储在代码段(常量区)，但数组是将常量拷贝到数组中，而数组在栈上。若是指针，则*p得到的字符串常量字符在代码段(静态区)


一.友元
1.友元分为：友元函数和友元类
2.功能：友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。
2.诞生原因：
(1)因为cout的输出流对象和隐含的this指针在抢占第一个参数的位置,因此有：_d<<cout(语法可行，但实际不可行)
(2)将operator<<重载成全局函数。但又会导致类外没办法访问成员，此时就需要友元来解决。operator>>同理。
3.特点：
(1)友元函数可以直接访问类的私有和保护成员，它是定义在类外部的普通函数，不是类的成员函数
(2)友元函数不能用const修饰
(3)友元函数可以在类定义的任何地方声明，不受类访问限定符限制
(4)一个函数可以是多个类的友元函数

二.内部类
1.定义：如果一个类定义在另一个类的内部，这个内部类就叫做内部类
2.特点：
(1) 内部类B 受到外部类A的限制，内部类可以定义在外部类的public、protected、private都是可以的。
(2) 内部类天生是外部类的友元类
(3)内部类B可访问外部类A的static成员，且可以通过外部类的对象参数来访问外部类中的所有成员，不需要外部类的对象/类名。外部类不能访问内部类的私有或保护型数据
(4)sizeof在计算时，内部类不参与计算(因为没开空间)
class A2
{
private:

    class B2
    {
        void func(A2* p)
        {
            p->_a1++;
        }
    private:
        int _b1;
    };
private:
    int _a1;
    int _a2;
    //报错，B可访问A，A不能访问B(私有或保护型数据)
    //void fx(B2* ptr)
    //{
    //    ptr->_b1++;
    //}
};
三.匿名对象
1.特点：
(1)不用取名字
(2)生命周期只有这一行，因此下一行就会自动调用析构函数
2.产生匿名对象的三种情况：
(1)以值的方式给函数传参:
Cat(); —> 生成了一个匿名对象，执行完Cat( )代码后，此匿名对象就此消失。这就是匿名对象的生命周期。
Cat cc = Cat(); —>首先生成了一个匿名对象，然后将此匿名对象变为了cc对象，其生命周期就变成了cc对象的生命周期。
(2)类型转换
(3)函数需要返回一个对象时:  return temp;
3..格式：
有名对象
A aa1;
Cat cc = Cat();

无名对象
Cat();
A aa2(2);
Solution().Sum_Solution(10);
4.总结：
如果生成的匿名对象在外部有对象等待被其实例化，此匿名对象的生命周期就变成了外部对象的生命周期；
如果生成的匿名对象在外面没有对象等待被其实例化，此匿名对象将会生成之后，立马被析构。
