一.再谈构造函数
1.构造函数体赋值:初始化只能初始化一次，而构造函数体内可以多次赋值
2.初始化列表
(1)每个成员变量在初始化列表中只能出现一次
(2) 类中的 "引用成员变量", "const成员变量", "自定义类型成员(且该类没有默认构造函数时)"，必须在初始化列表初始化(初始化列表最优先，其次缺省值，再其次随机值)
(3)自定义类型成员变量一定会先使用初始化列表初始化。(无论是否使用了初始化列表)
(4)成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后
次序无关
(5)格式：
class A
{
public:
 A(int a)
 :_a(a)
 {}
private:
 int _a;
};

class B
{
public:
 B(int a, int ref)
 :_aobj(a)
 ,_ref(ref)
 ,_n(10)
 {
     cout<<_aobj<<_ref<<_n<<endl; 
 }
private:
 A _aobj;  // 没有默认构造函数
 int& _ref;  // 引用
 const int _n; // const 
};
3.关键字：explicit
(1)功能：禁止构造函数的隐式转换
(构造函数对于单个参数或者除第一个参数无默认值其余均有默认值的构造函数，还具有类型转换的作用。)
(2)格式：
class Date
{
public:
    // 1. 单参构造函数，没有使用explicit修饰，具有类型转换作用
    // 创建对象时后1个参数可以不传递
    explicit Date(int year,int month=5)
        :_year(year)
    {}
private:
    int _year;
    int _month;
};
int main()
{
    Date d1(2002);//通过
 
  编译器背后会用2023构造一个无名对象，最后用无名对象给d1对象进行赋值
    d1 = 2023;//去掉explicit可通过
    return 0;
}
二.static成员
1.定义：声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。静态成员变量一定要在类外进行初始化
2.特性：
(1) 静态成员为所有类对象所共享，,不属于某个具体的对象，存放在静态区(生命期不依赖于任何对象，为程序的生命周期)
(2) 直接使用static关键字修饰即可
(3) 类静态成员即可用 类名::静态成员 或者 对象.静态成员 来访问(静态成员函数只能直接访问静态成员变量和静态成员函数,权限问题)
(4) 静态成员函数没有隐藏的this指针，不能访问任何非静态成员
(5) 静态成员是类的特殊成员，静态成员函数是类的一个特殊的成员函数，都受到public、protected、private 访问限定符的限制
(6)需要在类外单独分配空间




三.权限可缩小，不可放大(但是如果接受返回值的变量被强转为非const的， 也是可以被修改)
例1：
const Date d1(2024,1,31);//可读，不可写
d1.Print();
//void Print()//可读可写，权限放大(只有指针或引用才存在放大)，错误
//{
//    cout<<_year<<endl;
//}
void Print() const//修饰this指针。可读，不可写，权限平移
{
    cout<<_year<<endl;
}
例2：
Date d2(2024,3,31);
d2.Print();//权限的缩小

例3：
const int i=0;
int j=i;//j的改变不影响i
int& r=i;//r的改变影响i，权限放大，
const int* p1=&i;//权限平移
int* p2=p1;//权限放大
四.单参数构造函数支持隐式类型的转换(可使用关键字：explicit 取消隐式类型转换)
C cc2=2;
const C& cc3=2;
含义：2会构造一个临时对象，再拷贝构造。但编译器对同一个表达式连续步骤的构造，一般会被合二为一

五.static成员函数没有this指针(目的是为了访问静态成员变量)
