//仅反转字母

class Solution {
public:
bool isZiMu(char ch)
{
    if(ch>='A' && ch<='Z')
    return true;
    if(ch>='a'&&ch<='z')
    return true;

    return false;
}

    string reverseOnlyLetters(string s) {
        int j=s.size()-1;
        int i=0;
        while(i<j)
        {
            if(  ((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))&&((s[j]>='a' && s[j]<='z') || (s[j]>='A' && s[j]<='Z'))           )
            {
                swap(s[i++],s[j--]);
            }
            while(i<j &&  !isZiMu(s[i])   )
            {
                i++;
            }
            if(  i<j && !isZiMu(s[j]) )
            {
                j--;
            }
        }
        return s;
    }
};

//字符串相加
class Solution {
public:
    string addStrings(string num1, string num2) {
        string str;
        int end1=num1.size()-1;
        int end2=num2.size()-1;
        int next=0;
        int val=0;
        str.reserve(num1.size()>num2.size()?num1.size()+1 : num2.size()+1);
        while(end1>=0 || end2>=0)
        {
            int a1=end1>=0? num1[end1--]-'0':0;
            int a2=end2>=0? num2[end2--]-'0':0;

            val=a1+a2+next;
            next=val/10;
            val=val%10;
            str+=(val+'0');
        }
        if(next==1)
        {
            str+=(1+'0');
        }
        reverse(str.begin(),str.end());
        return str;
    }
};

//字符串只出现一次的字符
class Solution {
public:
    int firstUniqChar(string s) {
        int a[256] = {0};
        int size = s.size();
        for(int i=0;i<size;i++)
        {
              a[a.begin()-'a']++;
        }
        for(int i=0;i<size;i++)
        {
            if(a[s[i]]==1)
            {
                return i;
            }
        }
        return -1;

    }
};

//验证回文串
class Solution {
public:
    bool isPalindrome(string s) {
        string str;
        for(char c:s)
        {
            if(c>='a'&&c<='z')
            str+=c;
            if(c>='A'&&c<='Z')
            str+=(c+32);
            
        }
        string s1=str;
        reverse(str.begin(),str.end());
        if( str== s1)
        {
            return true;
        }
        return false;
    }
};

//反转单词
class Solution {
public:


    string reverseWords(string s) {
        int len=s.length();
        int i=0;
        while(i<len)
        {
            int begin=i;
            while(i<len && s[i]!=' ')
            {
                i++;
            }
            int end=i;
            reverse(s.begin()+begin,s.begin()+end);
            while( i<len && s[i]==' '   )
            {
                i++;
            }
        }
        return s;
    }
};

//部分翻转
class Solution {
public:
    string reverseStr(string s, int k) {
        int sz=s.size();
        for(int i=0;i<s.size();i+=k*2)
        {
            reverse(s.begin()+i,s.begin()+min(i+k,sz ) );
            //reverse(s.begin()+i,s.begin()+min(i+k,size()  ) );//编译错误
        }
        return s;
    }
};

//n以内自守数的数量
自守数是指一个数的平方的尾数等于该数自身的自然数。例如：25^2 = 625，76^2 = 5776，9376^2 = 87909376。请求出n(包括n)以内的自守数的个数
#include <iostream>
using namespace std;

int main() {
    int n;

    cin>>n;
    int count=0;
    while(n)
    {
    int m=n*n;
    int a=n,b=1;
    while(a)
    {
        a/=10;
        b*=10;
    }
    m=m%b;
    if(m==n)
    count++;
    n--;
    }
    cout<<(count+1);
}

//小于N的质数数量
#include <iostream>
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n;cin>>n;
    int count=0;
    while(n>1)
    {
        int flag=1;
        int m= sqrt(n)/1;
        while(m>1)
        {
            if(n%m==0)
            {
                flag=0;
                break;
            }
            m--;
        }
        if(flag==1)
        count++;
        n--;
    }
    cout<<count;
    return 0;
}
//第一个只出现一次的字符
    int FirstNotRepeatingChar(string str) {
        // write code here
        int a[300]={0};
        for(int i=0;i<str.size();i++)
        {
            int x=str[i];
            a[x]++;
        }
        for(int i=0;i<str.size();i++)
        {
            int x=str[i];
            if(a[x]==1)
            {
                return i;
            }
        }
        return -1;
    }
};
//确定一个字符串 s 的所有字符是否全都不同

bool isUnique(char* astr){
    int a[30]={0};
    while(*astr)
    {
        int x=*astr-'a';
        a[x]++;
        astr++;
    }
    for(int i=0;i<30;i++)
    {
        if(a[i]>1)
        {
            return false;
        }
    }
    return true;

}

//给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
class Solution {
public:
    bool canPermutePalindrome(string s) {
        int a[600]={0};
        for(int i=0;i<s.size();i++)
        {
            a[s[i]]++;
        }
        int flag=0;
        for(int i=0;i<600;i++)
        {
            if(a[i]%2==1)
            flag++;
        }
        if(flag>1)
        return false;
        return true;

    }
};
